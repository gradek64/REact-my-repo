import React from "react";
import logger from "node-color-log";
import ReactDOMServer from "react-dom/server";
import { Provider as ReduxProvider } from 'react-redux';
import { StaticRouter, matchPath } from "react-router-dom";
import Loadable from "react-loadable";
import { createMemoryHistory } from 'history';

 import serialize from "serialize-javascript";
import App from "../../shared/components/App";
import routes from "../../shared/routes";
import { processRoutes } from '../../shared/routes';
import { getJsFiles } from "../serverRenderingHelpers"; 



const ssrMiddleware = (req, res, next) => {
  logger.color("yellow").bold().log("requested req.url", req.url);
  //this goes through all routes in application;
  const activeRoute =
    routes.find((route, i) => matchPath(req.url, route)) || {};

  logger.color("yellow").bold().log("activeRoute", activeRoute);

  console.log('fine')
  /******** Redux server setup ******/

  // set initial store to be passed to client in window._data
  const initialState = {
    meta: {},
  };

  //U can not use BrowserRouter cause the routes are processed on server not a client
  const memoryHistory = createMemoryHistory({ initialEntries: [req.url] });
  // const store = configureStore(memoryHistory, initialState);

  /****/

  // Waits for asynchronous actions like API calls
  // before rendering the HTML
  // undefined is a way of not setting a value for the first param in this case
  // processRoutes(routesProcessing = routes,store, req) = undefined will cause routesProcessing = routes so will take default of the function
  const waitForAsyncActions = [processRoutes(
    undefined,
    memoryHistory,
    initialState,
    req,
    res
  )];
  console.log('waitForAsyncActions')

    Promise.all(waitForAsyncActions)
    // Promise all resolve all promises result in array so [store]
    .then(([store]) => {
      // Create a context for <StaticRouter>, which will allow us to
      // query for the results of the render.
      const context = {
        status: 200,
      };

      // console.log('store', store.getState())

      // As we are code splitting, we need to find out which chunks
      // the SSR uses so the client can use them. <Loadable.Capture>
      // takes a report prop which is called whenever a chunk is used.
      const modules = [];

      logger
        .color('yellow')
        .bold()
        .log('requested req.url in promise response', req.url);

      // Render the part of the app that gets hydrated on the client
      const appHtml = ReactDOMServer.renderToString(
        <Loadable.Capture report={(moduleName) => modules.push(moduleName)}>
          <ReduxProvider store={store}>
            <StaticRouter location={req.url} context={context}>
              <App />
            </StaticRouter>
          </ReduxProvider>
        </Loadable.Capture>
      );

      const BodyContentAndScripts = ({ client, modulesChunks }) => {
        return (
          <body>
            <div id='app' dangerouslySetInnerHTML={{ __html: client }} />
            {getJsFiles(modulesChunks)}
          </body>
        );
      };

      const serverHtml = ReactDOMServer.renderToString(
        <BodyContentAndScripts client={appHtml} modulesChunks={modules} />
      );

      res.send(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>SSR with RR</title>
          <!-- this has been generated by config/client/webpack.dev.config -->
          <script>window.__INITIAL_DATA__ = ${serialize({})}</script>
          <link rel="stylesheet" type="text/css" href="./style.css" />

        </head>
       ${serverHtml}
      </html>
      `);
    })
    .catch(next);
}; 

export default ssrMiddleware;
